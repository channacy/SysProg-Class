1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

 > **Answer**: All child processes are made sure to complete because the waitpid() function is used to wait for all the child processes to complete before leaving the execute_pipeline() function. Before this, the parent process also closes all the pipe file descriptors as well. If waitpid() was not called on all child processes, the next shell prompt won't be printed and there will be continous waiting for the child processes to finish. The child processes could also later become zombie processes.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

 > **Answer**: It is necessary to close unused pipe ends after calling dup2() because without it, the stdout would not be setup correctly and resources such as file descriptors would be held. If pipes are left open, a deadlock could occur in which a child process and parent process have their pipes open and are waiting for each other to read or write data from the pipe.

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

 > **Answer**: The cd command is a built-in command because it affects the current shell's working directory and would ideally work faster if the command was built-in rather than calling a separate process to execute it as an external command. On the other hand, if cd were implemented as an external process, it would not be effective because a child process cannot alter the path or environment of its parent process so potential additional steps may be needed so the current path of the parent process (or shell) being used can be affected.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

 > **Answer**: To allow an arbitary number of piped comands while still handling memory allocation efficiently, the number of commands in piped commands would be considered and memory would be allocated based on that count to save all the commands and its arguments in clist. A pipe would be created for each pair of commands and child processes would be forked and will set up the file descriptors and then execute the command. The first command will read from stdin and write to the pipe while the subsequent commands will have redirected stdin and stdout and the last command in the piped command will read from the pipe's end and write to stdout. Trade-offs include consideration of limited number of file descriptors that an operating system can have, and also robust error handling for the many running child processes and proper resource management (with redirecting stdin and stdout with pipes) while also preventing potential deadlock between two or more processes.
